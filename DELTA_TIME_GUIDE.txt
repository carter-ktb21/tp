================================================================================
                    DELTA_TIME vs SCALE_TIME Guide
                    For 60fps Port of Twilight Princess
================================================================================

OVERVIEW
--------
The game was originally designed to run at 30fps. To make it work correctly at
60fps, we need to adjust timing in two different ways depending on what we're
scaling:

1. SCALE_TIME - For timers and counters
2. DELTA_TIME - For movement and smooth changes


================================================================================
SCALE_TIME - For Timers/Counters
================================================================================

VALUES:
  30fps: SCALE_TIME = 1
  60fps: SCALE_TIME = 2

PURPOSE:
  Make timers last the same real-world duration regardless of framerate

WHEN TO USE:
  - Initializing countdown timers
  - Setting animation durations (in frames)
  - Any counter that gets decremented by 1 each frame

PATTERN:
  Multiply by SCALE_TIME when initializing, then decrement with -- operator

EXAMPLE:
  // Timer should last 1 second (30 frames at 30fps, 60 frames at 60fps)
  mDashTimer = 30 * SCALE_TIME;

  // Each frame in the game loop:
  if (mDashTimer != 0) {
      mDashTimer--;  // Just subtract 1, no DELTA_TIME needed!
  }

WHY IT WORKS:
  At 60fps, timer starts at 60 instead of 30
  But we're running twice as many frames, so it still takes 1 second


================================================================================
DELTA_TIME - For Movement/Smooth Changes
================================================================================

VALUES:
  30fps: DELTA_TIME = 1.0
  60fps: DELTA_TIME = 0.5

PURPOSE:
  Make per-frame changes smaller at higher framerates so total movement over
  time stays consistent

WHEN TO USE:
  - Movement speed calculations
  - Rotation/angle changes
  - Any gradual change that happens every frame
  - Inside utility functions like cLib_addCalcAngleS, cLib_chaseF, etc.

PATTERN:
  Calculate the change, then multiply by DELTA_TIME when applying it

EXAMPLE:
  // Movement - should move 10 units per 30fps frame
  void fopAcM_calcSpeed(fopAc_ac_c* i_actor) {
      f32 speedF = fopAcM_GetSpeedF(i_actor) * DELTA_TIME;
      // speedF will be half at 60fps, but applied twice as often
  }

  // Rotation - should smoothly rotate toward target
  s16 cLib_addCalcAngleS(...) {
      s16 step = diff / scale;           // Calculate step normally
      *pvalue += step * DELTA_TIME;      // Apply half the step at 60fps
  }

WHY IT WORKS:
  At 60fps, each step is 0.5x smaller
  But we're running twice as many frames, so total movement is the same


================================================================================
CRITICAL RULE: Scale INSIDE Functions, NOT at Call Sites
================================================================================

WRONG - Scaling at call sites:
  // DON'T DO THIS!
  cLib_addCalcAngleS(&angle, target, 4 * DELTA_TIME, 0x1000, 0x100);

  Problem: If cLib_addCalcAngleS also uses DELTA_TIME internally,
           this causes DOUBLE SCALING and makes movement too slow!

RIGHT - Scaling inside the function:
  // Caller just passes normal values
  cLib_addCalcAngleS(&angle, target, 4, 0x1000, 0x100);

  // Function handles DELTA_TIME internally
  s16 cLib_addCalcAngleS(s16* pvalue, s16 target, const s16 scale, ...) {
      s16 step = diff / scale;
      *pvalue += step * DELTA_TIME;  // DELTA_TIME applied here
  }

WHY THIS MATTERS:
  - Consistency: All callers automatically get correct behavior
  - No double scaling: DELTA_TIME only applied once
  - Easier to maintain: Fix it once in the function, works everywhere


================================================================================
NEVER DIVIDE BY DELTA_TIME
================================================================================

WRONG:
  step = diff / (scale * DELTA_TIME);  // DON'T DO THIS!

WHY IT'S WRONG:
  At 60fps where DELTA_TIME = 0.5:
  - Dividing by 0.5 is the same as multiplying by 2
  - This makes the step LARGER instead of smaller
  - Combined with running twice as many frames = 4x too fast!

RIGHT:
  step = diff / scale;          // Calculate step normally
  *pvalue += step * DELTA_TIME; // MULTIPLY when applying


================================================================================
Quick Reference Table
================================================================================

What are you doing?              | Use this:        | How:
---------------------------------|------------------|------------------------
Setting a timer                  | SCALE_TIME       | timer = frames * SCALE_TIME
Decrementing a timer             | Just use --      | if (timer) timer--;
Movement speed                   | DELTA_TIME       | speed * DELTA_TIME
Angle changes                    | DELTA_TIME       | angle += step * DELTA_TIME
Gradual value changes            | DELTA_TIME       | value += change * DELTA_TIME
Animation frame advances         | Nothing          | Frame++ (already frame-based)


================================================================================
Common Functions Already Handling DELTA_TIME Internally
================================================================================

These functions already handle DELTA_TIME, so DON'T multiply their parameters:

- cLib_addCalcAngleS()   - Smooth angle interpolation
- cLib_chaseAngleS()     - Chase angle with constant step
- cLib_addCalcAngleS2()  - Alternative angle interpolation
- cLib_chaseF()          - Chase float value
- fopAcM_calcSpeed()     - Calculate actor movement speed

Just pass normal values to these functions!


================================================================================
Examples from the Codebase
================================================================================

TIMERS (use SCALE_TIME):
  // src/d/actor/d_a_alink_swim.inc:1118
  mWolfDashDistTimer = mpHIO->mSwim.m.field_0x5c * SCALE_TIME;

  // src/d/actor/d_a_alink.cpp:17240
  if (mWolfDashTimer != 0) {
      mWolfDashTimer--;  // No DELTA_TIME needed!
  }

MOVEMENT (use DELTA_TIME):
  // src/f_op/f_op_actor_mng.cpp:540
  void fopAcM_calcSpeed(fopAc_ac_c* i_actor) {
      f32 speedF = fopAcM_GetSpeedF(i_actor) * DELTA_TIME;
      // ... calculate movement with scaled speed
  }

ANGLES (use DELTA_TIME):
  // src/SSystem/SComponent/c_lib.cpp:242
  s16 cLib_addCalcAngleS(s16* pvalue, s16 target, const s16 scale, ...) {
      s16 step = diff / scale;
      *pvalue += step * DELTA_TIME;  // Scaled inside the function
  }


================================================================================
Troubleshooting
================================================================================

Movement too fast?
  - Check if you're dividing by DELTA_TIME (should multiply instead)
  - Check for double scaling (DELTA_TIME at call site AND inside function)

Movement too slow?
  - Might be missing DELTA_TIME scaling in the movement function
  - Check if the function already handles it internally

Jittery/stuttery movement?
  - Usually caused by DELTA_TIME being applied at call sites when the
    function already handles it internally
  - Remove DELTA_TIME from the function parameters

Timers too short?
  - Should use SCALE_TIME when initializing: timer = value * SCALE_TIME

Timers too long?
  - Check you're not using both SCALE_TIME and DELTA_TIME on timers
  - Timers should only use SCALE_TIME at initialization


================================================================================
